# 4. Median of Two Sorted Arrays

[Problem Link](https://leetcode.com/problems/median-of-two-sorted-arrays/)

## Solution

* 暴力解非常的簡單，O(m+n)就能搞定，算式也不會太複雜
* 研究了一下最佳解需要使用Divide and Conquer的概念，於是應用了Binary Search解題
* 題目期望找到兩組已排序數列合併後的中位數

1. 找出較短的數列m以他為主，另一數組則為n
2. 將m以中心切一刀，分成兩塊，n數組也進行切分，切分位置必須滿足在加到m的兩分塊時，兩邊數量能夠平衡
3. 觀察m和n的數組切面是否有彼此符合排序定義，即左邊的max(m,n)要小於右邊的min(m,n)
4. 符合則計算中位數直接輸出
5. 不符合則依照m的大小決定往左或往右重新找中心線再切一刀
6. 若m1 > n2則往左切, m2 < n1則往右切，再來重複回第三步驟，直到找到解

```
... m1 || m2 ...
... n1 || n2 ...
```

```
Sample
m = [ 1,  3,  8,  9, 15]
n = [ 7, 11, 18, 19, 21, 25]

切第一刀(中心):
m = [ 1,  3,         ||  8,  9, 15]
n = [ 7, 11, 18, 19, || 21, 25]
n為了讓左右數量平衡，所以切的位置是19跟21之間
但這裡8<19(m2<n1)，表示這刀不是切到中位數，要再往右切，因此往右邊的中間再切(二元搜尋法)

切第二刀:
m = [ 1,  3,  8, ||  9, 15]
n = [ 7, 11, 18, || 19, 21, 25]
這裡9<18(m2<n1)，同理再往右邊中間切

切第三刀:
m = [ 1,  3,  8,  9, || 15]
n = [ 7, 11,         || 18, 19, 21, 25]
這裡15>11正確，9<18也正確，那中位數必定在這四個數之間，設計上為奇數長度時都是左邊會多一個
因此中位數會是max(9, 11) = 11

偶數的作法也差不多，影片內有詳細說明
```

[此題的詳細解說影片](https://www.youtube.com/watch?v=LPFhl65R7ww)

算法效率: O(log(min(num1, num2)))<br>

